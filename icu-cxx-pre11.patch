diff -urNp -x '*.orig' icu.org/source/common/unicode/char16ptr.h icu/source/common/unicode/char16ptr.h
--- icu.org/source/common/unicode/char16ptr.h	2020-04-22 22:04:20.000000000 +0200
+++ icu/source/common/unicode/char16ptr.h	2021-08-28 18:37:59.680815945 +0200
@@ -64,12 +64,14 @@ public:
      */
     inline Char16Ptr(wchar_t *p);
 #endif
+#ifdef U_HAS_NULLPTR_T
     /**
      * nullptr constructor.
      * @param p nullptr
      * @stable ICU 59
      */
     inline Char16Ptr(std::nullptr_t p);
+#endif
     /**
      * Destructor.
      * @stable ICU 59
@@ -118,7 +120,9 @@ Char16Ptr::Char16Ptr(uint16_t *p) : p_(c
 #if U_SIZEOF_WCHAR_T==2
 Char16Ptr::Char16Ptr(wchar_t *p) : p_(cast(p)) {}
 #endif
+#ifdef U_HAS_NULLPTR_T
 Char16Ptr::Char16Ptr(std::nullptr_t p) : p_(p) {}
+#endif
 Char16Ptr::~Char16Ptr() {
     U_ALIASING_BARRIER(p_);
 }
@@ -134,7 +138,9 @@ Char16Ptr::Char16Ptr(uint16_t *p) { u_.u
 #if U_SIZEOF_WCHAR_T==2
 Char16Ptr::Char16Ptr(wchar_t *p) { u_.wp = p; }
 #endif
+#ifdef U_HAS_NULLPTR_T
 Char16Ptr::Char16Ptr(std::nullptr_t p) { u_.cp = p; }
+#endif
 Char16Ptr::~Char16Ptr() {}
 
 char16_t *Char16Ptr::get() const { return u_.cp; }
@@ -171,12 +177,14 @@ public:
      */
     inline ConstChar16Ptr(const wchar_t *p);
 #endif
+#ifdef U_HAS_NULLPTR_T
     /**
      * nullptr constructor.
      * @param p nullptr
      * @stable ICU 59
      */
     inline ConstChar16Ptr(const std::nullptr_t p);
+#endif
 
     /**
      * Destructor.
@@ -226,7 +234,9 @@ ConstChar16Ptr::ConstChar16Ptr(const uin
 #if U_SIZEOF_WCHAR_T==2
 ConstChar16Ptr::ConstChar16Ptr(const wchar_t *p) : p_(cast(p)) {}
 #endif
+#ifdef U_HAS_NULLPTR_T
 ConstChar16Ptr::ConstChar16Ptr(const std::nullptr_t p) : p_(p) {}
+#endif
 ConstChar16Ptr::~ConstChar16Ptr() {
     U_ALIASING_BARRIER(p_);
 }
@@ -242,7 +252,9 @@ ConstChar16Ptr::ConstChar16Ptr(const uin
 #if U_SIZEOF_WCHAR_T==2
 ConstChar16Ptr::ConstChar16Ptr(const wchar_t *p) { u_.wp = p; }
 #endif
+#ifdef U_HASH_NULLPTR_T
 ConstChar16Ptr::ConstChar16Ptr(const std::nullptr_t p) { u_.cp = p; }
+#endif
 ConstChar16Ptr::~ConstChar16Ptr() {}
 
 const char16_t *ConstChar16Ptr::get() const { return u_.cp; }
diff -urNp -x '*.orig' icu.org/source/common/unicode/platform.h icu/source/common/unicode/platform.h
--- icu.org/source/common/unicode/platform.h	2020-04-22 22:04:20.000000000 +0200
+++ icu/source/common/unicode/platform.h	2021-08-28 18:37:59.680815945 +0200
@@ -514,6 +514,10 @@
 namespace std {
   typedef decltype(nullptr) nullptr_t;
 };
+#   define U_HAS_NULLPTR_T 1
+#elif defined(__cplusplus) && (U_CPLUSPLUS_VERSION >= 11)
+#   define U_HAS_NULLPTR_T 1
+// else no U_HAS_NULLPTR_T
 #endif
 
 /**
diff -urNp -x '*.orig' icu.org/source/common/unicode/umachine.h icu/source/common/unicode/umachine.h
--- icu.org/source/common/unicode/umachine.h	2020-04-22 22:04:20.000000000 +0200
+++ icu/source/common/unicode/umachine.h	2021-08-28 18:37:59.680815945 +0200
@@ -320,7 +320,7 @@ typedef int8_t UBool;
  * If 1, then char16_t is a typedef and not a real type (yet)
  * @internal
  */
-#if (U_PLATFORM == U_PF_AIX) && defined(__cplusplus) &&(U_CPLUSPLUS_VERSION < 11)
+#if ((U_PLATFORM == U_PF_AIX) || defined(__GNUC__)) && defined(__cplusplus) && (U_CPLUSPLUS_VERSION < 11)
 // for AIX, uchar.h needs to be included
 # include <uchar.h>
 # define U_CHAR16_IS_TYPEDEF 1
diff -urNp -x '*.orig' icu.org/source/common/unicode/unistr.h icu/source/common/unicode/unistr.h
--- icu.org/source/common/unicode/unistr.h	2020-04-22 22:04:20.000000000 +0200
+++ icu/source/common/unicode/unistr.h	2021-08-28 18:37:59.684149282 +0200
@@ -3014,6 +3014,7 @@ public:
       UnicodeString(ConstChar16Ptr(text)) {}
 #endif
 
+#ifdef U_HAS_NULLPTR_T
   /**
    * nullptr_t constructor.
    * Effectively the same as the default constructor, makes an empty string object.
@@ -3025,6 +3026,7 @@ public:
    * @stable ICU 59
    */
   UNISTR_FROM_STRING_EXPLICIT inline UnicodeString(const std::nullptr_t text);
+#endif
 
   /**
    * char16_t* constructor.
@@ -3061,6 +3063,7 @@ public:
       UnicodeString(ConstChar16Ptr(text), textLength) {}
 #endif
 
+#ifdef U_HAS_NULLPTR_T
   /**
    * nullptr_t constructor.
    * Effectively the same as the default constructor, makes an empty string object.
@@ -3069,6 +3072,7 @@ public:
    * @stable ICU 59
    */
   inline UnicodeString(const std::nullptr_t text, int32_t textLength);
+#endif
 
   /**
    * Readonly-aliasing char16_t* constructor.
@@ -3143,6 +3147,7 @@ public:
       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}
 #endif
 
+#ifdef U_HAS_NULLPTR_T
   /**
    * Writable-aliasing nullptr_t constructor.
    * Effectively the same as the default constructor, makes an empty string object.
@@ -3152,6 +3157,7 @@ public:
    * @stable ICU 59
    */
   inline UnicodeString(std::nullptr_t buffer, int32_t buffLength, int32_t buffCapacity);
+#endif
 
 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
 
@@ -3859,6 +3865,7 @@ UnicodeString::UnicodeString() {
   fUnion.fStackFields.fLengthAndFlags=kShortString;
 }
 
+#ifdef U_HAS_NULLPTR_T
 inline UnicodeString::UnicodeString(const std::nullptr_t /*text*/) {
   fUnion.fStackFields.fLengthAndFlags=kShortString;
 }
@@ -3870,6 +3877,7 @@ inline UnicodeString::UnicodeString(cons
 inline UnicodeString::UnicodeString(std::nullptr_t /*buffer*/, int32_t /*buffLength*/, int32_t /*buffCapacity*/) {
   fUnion.fStackFields.fLengthAndFlags=kShortString;
 }
+#endif
 
 //========================================
 // Read-only implementation methods
@@ -3920,7 +3928,11 @@ UnicodeString::isBufferWritable() const
 inline const char16_t *
 UnicodeString::getBuffer() const {
   if(fUnion.fFields.fLengthAndFlags&(kIsBogus|kOpenGetBuffer)) {
+#ifdef U_HAS_NULLPTR_T
     return nullptr;
+#else
+    return 0;
+#endif
   } else if(fUnion.fFields.fLengthAndFlags&kUsingStackBuffer) {
     return fUnion.fStackFields.fBuffer;
   } else {
